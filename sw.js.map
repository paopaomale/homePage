{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/js/sw/index.js","node_modules/serviceworker-cache-polyfill/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sw.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/**\n * Copyright 2015 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nrequire('serviceworker-cache-polyfill');\n\nvar version = 'v15';\nvar staticCacheName = 'trains-static-v15';\n\nself.oninstall = function(event) {\n  self.skipWaiting();\n\n  event.waitUntil(\n    caches.open(staticCacheName).then(function(cache) {\n      return cache.addAll([\n        './',\n        'css/all.css',\n        'js/page.js',\n        'imgs/logo.svg',\n        'imgs/icon.png'\n      ]);\n    })\n  );\n};\n\nvar expectedCaches = [\n  staticCacheName,\n  'trains-imgs',\n  'trains-data'\n];\n\nself.onactivate = function(event) {\n  if (self.clients && clients.claim) {\n    clients.claim();\n  }\n\n  // remove caches beginning \"trains-\" that aren't in\n  // expectedCaches\n  event.waitUntil(\n    caches.keys().then(function(cacheNames) {\n      return Promise.all(\n        cacheNames.map(function(cacheName) {\n          if (/^trains-/.test(cacheName) && expectedCaches.indexOf(cacheName) == -1) {\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    })\n  );\n};\n\nself.onfetch = function(event) {\n  var requestURL = new URL(event.request.url);\n\n  if (requestURL.hostname == 'api.flickr.com') {\n    event.respondWith(flickrAPIResponse(event.request));\n  }\n  else if (/\\.staticflickr\\.com$/.test(requestURL.hostname)) {\n    event.respondWith(flickrImageResponse(event.request));\n  }\n  else {\n    event.respondWith(\n      caches.match(event.request, {\n        ignoreVary: true\n      })\n    );\n  }\n};\n\nfunction getPhotoURL(photo) {\n  return 'https://farm' + photo.farm + '.staticflickr.com/' + photo.server + '/' + photo.id + '_' + photo.secret + '_c.jpg';\n}\n\nfunction flickrAPIResponse(request) {\n  if (request.headers.get('x-use-cache-only')) {\n    return caches.match(request);\n  }\n  else if (request.headers.get('x-cache-warmup')) {\n    var headers = new Headers(request.headers);\n    headers.delete('x-cache-warmup');\n    return flickrAPIResponse(new Request(request, {headers: headers})).then(function(response) {\n      return response.json();\n    }).then(function(data) {\n      var imgRequests = data.photos.photo.map(getPhotoURL).map(function(url) {\n        return new Request(url, {mode: 'no-cors'});\n      });\n      return Promise.all(imgRequests.map(flickrImageResponse));\n    }).then(function() {\n      return caches.match(request);\n    });\n  }\n  else {\n    return fetch(request).then(function(response) {\n      return caches.open('trains-data').then(function(cache) {\n        // clean up the image cache\n        Promise.all([\n          response.clone().json(),\n          caches.open('trains-imgs')\n        ]).then(function(results) {\n          var data = results[0];\n          var imgCache = results[1];\n\n          var imgURLs = data.photos.photo.map(getPhotoURL);\n\n          // if an item in the cache *isn't* in imgURLs, delete it\n          imgCache.keys().then(function(requests) {\n            requests.forEach(function(request) {\n              if (imgURLs.indexOf(request.url) == -1) {\n                imgCache.delete(request);\n              }\n            });\n          });\n        });\n\n        cache.put(request, response.clone());\n\n        return response;\n      });\n    });\n  }\n}\n\nfunction flickrImageResponse(request) {\n  return caches.match(request).then(function(response) {\n    if (response) {\n      return response;\n    }\n\n    return fetch(request).then(function(response) {\n      caches.open('trains-imgs').then(function(cache) {\n        cache.put(request, response);\n      });\n\n      return response.clone();\n    });\n  });\n}\n","if (!Cache.prototype.add) {\n  Cache.prototype.add = function add(request) {\n    return this.addAll([request]);\n  };\n}\n\nif (!Cache.prototype.addAll) {\n  Cache.prototype.addAll = function addAll(requests) {\n    var cache = this;\n\n    // Since DOMExceptions are not constructable:\n    function NetworkError(message) {\n      this.name = 'NetworkError';\n      this.code = 19;\n      this.message = message;\n    }\n    NetworkError.prototype = Object.create(Error.prototype);\n\n    return Promise.resolve().then(function() {\n      if (arguments.length < 1) throw new TypeError();\n      \n      // Simulate sequence<(Request or USVString)> binding:\n      var sequence = [];\n\n      requests = requests.map(function(request) {\n        if (request instanceof Request) {\n          return request;\n        }\n        else {\n          return String(request); // may throw TypeError\n        }\n      });\n\n      return Promise.all(\n        requests.map(function(request) {\n          if (typeof request === 'string') {\n            request = new Request(request);\n          }\n\n          var scheme = new URL(request.url).protocol;\n\n          if (scheme !== 'http:' && scheme !== 'https:') {\n            throw new NetworkError(\"Invalid scheme\");\n          }\n\n          return fetch(request.clone());\n        })\n      );\n    }).then(function(responses) {\n      // TODO: check that requests don't overwrite one another\n      // (don't think this is possible to polyfill due to opaque responses)\n      return Promise.all(\n        responses.map(function(response, i) {\n          return cache.put(requests[i], response);\n        })\n      );\n    }).then(function() {\n      return undefined;\n    });\n  };\n}\n"]}